<!doctype html>
<html lang="sv">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Bingo-Utmaningar</title>
  <style>
    :root{
      --bg-zoom: 240%;
      --bg-pos-x: 50%;
      --bg-pos-y: 50%;
      --bingo-shift: 20vh;
    }

    body {
      font-family: Arial, sans-serif;
      color: white;
      text-align: center;
      margin: 0;
      min-height: 100vh;
      overflow-x: hidden;
      position: relative;
      background: #1d1f27;
    }

    .background{
      position: fixed;
      inset: 0;
      background: url("letsboat-bg.png") no-repeat center center;
      background-size: var(--bg-zoom);
      background-position: var(--bg-pos-x) var(--bg-pos-y);
      z-index: -2;
    }
    .overlay{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.3);
      z-index: -1;
    }

    .page{
      padding: 10px 10px 20px;
      margin-top: var(--bingo-shift);
    }

    h1 {
      margin-bottom: 15px;
      font-size: 1.5em;
      text-shadow: 0 2px 6px rgba(0,0,0,0.4);
    }

    .bingo-board {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 6px;
      width: 100%;
      max-width: 450px;
      margin: auto;
    }

    .cell {
      background: #2a2d38;
      border-radius: 8px;
      font-size: clamp(0.6em, 2.5vw, 0.9em);
      cursor: pointer;
      user-select: none;
      transition: background 0.3s, transform 0.2s;
      word-wrap: break-word;
      padding: 5px;
      aspect-ratio: 1 / 1;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
    }
    .cell.marked {
      background: #6C63FF;
      text-decoration: line-through;
      position: relative;
    }
    .cell.marked::after{
      content: attr(data-prooficon);
      position: absolute;
      bottom: 4px;
      right: 6px;
      font-size: 1.1em;
      opacity: 0.95;
    }
    .cell:active { transform: scale(0.95); }

    .progress {
      margin-top: 12px;
      font-size: 0.95em;
      color: #ffd700;
      font-weight: bold;
      text-shadow: 0 1px 3px rgba(0,0,0,0.4);
    }

    .back-btn {
      position: fixed;
      top: 15px;
      right: 15px;
      background: #6C63FF;
      color: #fff;
      border: none;
      padding: 8px 14px;
      border-radius: 8px;
      font-size: 1em;
      font-weight: bold;
      cursor: pointer;
      z-index: 1000;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
      transition: background 0.2s;
    }
    .back-btn:hover { background: #5a54d6; }

    /* ===== Modals ===== */
    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.5);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
      padding: 20px;
    }
    .modal {
      background: #2a2d38;
      color: #fff;
      width: 100%;
      max-width: 420px;
      border-radius: 12px;
      padding: 18px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.4);
      text-align: left;
    }
    .modal h3 {
      margin: 0 0 8px 0;
      font-size: 1.2em;
    }
    .modal p {
      margin: 0 0 14px 0;
      color: #ddd;
      font-size: 0.95em;
    }
    .modal .row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: 10px;
    }
    .btn {
      appearance: none;
      border: none;
      border-radius: 10px;
      padding: 10px 14px;
      font-weight: 700;
      cursor: pointer;
      background: #6C63FF;
      color: #fff;
      flex: 1;
      text-align: center;
    }
    .btn.secondary { background: #3a3e4e; }
    .btn:hover { filter: brightness(1.05); }
    .modal textarea {
      width: 100%;
      min-height: 110px;
      border-radius: 10px;
      border: none;
      padding: 10px;
      resize: vertical;
      background: rgba(255,255,255,0.08);
      color: #fff;
      outline: none;
      font-size: 0.95em;
    }
    .meta {
      font-size: 0.85em;
      color: #bbb;
      margin-top: 8px;
    }
  </style>
</head>
<body>
  <div class="background"></div>
  <div class="overlay"></div>

  <button class="back-btn" onclick="goBack()">‚üµ Tillbaka</button>

  <div class="page">
    <h1>üéâ Ingrids Bingo-Utmaningar</h1>
    <div class="bingo-board" id="board"></div>
    <div class="progress" id="progressText">Du har klarat 0 av 16 utmaningar</div>
  </div>

  <!-- ===== Proof chooser modal ===== -->
  <div class="modal-backdrop" id="chooserBackdrop" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="chooserTitle">
      <h3 id="chooserTitle">V√§lj bevis</h3>
      <p id="chooserTaskText">V√§lj hur du vill styrka rutan.</p>
      <div class="row">
        <button class="btn" id="chooseTextBtn">‚úçÔ∏è Skriv text</button>
        <button class="btn" id="choosePhotoBtn">üì∑ Ladda upp foto</button>
      </div>
      <div class="row" style="margin-top:8px;">
        <button class="btn secondary" id="chooserCancel">Avbryt</button>
      </div>
      <div class="meta">Du m√•ste l√§mna bevis f√∂r att markera rutan.</div>
    </div>
  </div>

  <!-- ===== Text input modal ===== -->
  <div class="modal-backdrop" id="textBackdrop" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="textTitle">
      <h3 id="textTitle">Skriv en kort bekr√§ftelse</h3>
      <p id="textTaskText">Vad gjorde du?</p>
      <textarea id="proofText" placeholder="Ex: 'Sk√•lade med Anna vid baren'"></textarea>
      <div class="row" style="margin-top:12px;">
        <button class="btn" id="saveTextProof">Spara & markera</button>
        <button class="btn secondary" id="textCancel">Avbryt</button>
      </div>
    </div>
  </div>

  <!-- Hidden photo input (SAME id and behavior as player page) -->
  <input type="file" id="photoUpload" accept="image/*" capture="environment" style="display:none;">

  <script>
    // --- Sheety + Cloudinary setup ---
    const API_URL = "https://api.sheety.co/19d52e6f83ab4563121d3da380c48d62/bingoPlayers/blad1";
    const params = new URLSearchParams(window.location.search);
    const playerId = params.get("id");

    // Cloudinary (same as player page)
    const CLOUD_NAME = "dtweoqypu";
    const UPLOAD_PRESET = "Ingrid80";

    const challenges = [
      "Hitta n√•gon som har rest l√§ngst ‚úàÔ∏è",
      "Ta en selfie med f√∂delsedagsbarnet ü§≥",
      "Dansa med en fr√§mling üíÉ",
      "Hitta n√•gon med samma f√∂delsem√•nad üéÇ",
      "Sjung med i en l√•t üé∂",
      "Ber√§tta ett minne om Ingrid f√∂r Ingrid üó£Ô∏è",
      "Sk√•la med n√•gon du inte k√§nner ü•Ç",
      "Hitta n√•gon som heter p√• samma bokstav som du üî§",
      "G√∂r high five med en g√§st üôå",
      "S√§g 'Grattis Ingrid!' riktigt h√∂gt üéâ",
      "Hitta n√•gon som har p√• sig n√•got bl√•tt üíô",
      "Gissa vilken Ingrids favoritf√§rg √§r üé®",
      "Ta ett gruppfoto üì∏",
      "S√§g ett sk√§mt till n√•gon üòÇ",
      "Dansa i minst 30 sekunder üï∫",
      "Ta en shot! ü§ó"
    ];

    const boardElement = document.getElementById("board");
    const progressText = document.getElementById("progressText");

    // Modals & inputs
    const chooserBackdrop = document.getElementById("chooserBackdrop");
    const chooseTextBtn   = document.getElementById("chooseTextBtn");
    const choosePhotoBtn  = document.getElementById("choosePhotoBtn");
    const chooserCancel   = document.getElementById("chooserCancel");
    const textBackdrop    = document.getElementById("textBackdrop");
    const textCancel      = document.getElementById("textCancel");
    const saveTextProof   = document.getElementById("saveTextProof");
    const proofText       = document.getElementById("proofText");
    const photoInput      = document.getElementById("photoUpload");
    const chooserTaskText = document.getElementById("chooserTaskText");
    const textTaskText    = document.getElementById("textTaskText");

    let boardData = [];
    let marked = [];
    let evidence = []; // array of { type: 'text'|'photo', value: string (text or image URL), ts, name? } or null
    let pendingIndex = null; // which tile we are working on

    // ---- Utilities to get & save player data ----
    async function getPlayerRow() {
      const res = await fetch(`${API_URL}/${playerId}`);
      const json = await res.json();
      const sheetKey = Object.keys(json)[0];
      return json[sheetKey];
    }

    async function putPlayerFields(fields) {
      await fetch(`${API_URL}/${playerId}`, {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ blad1: fields })
      });
    }

    async function loadBoard() {
      const player = await getPlayerRow();

      let playerData = {};
      try { playerData = JSON.parse(player.data || "{}"); } catch {}

      if (playerData.challengeBoard && playerData.challengeBoard.length === 16) {
        boardData = playerData.challengeBoard;
        marked = playerData.challengeMarked || Array(16).fill(false);
        evidence = playerData.challengeEvidence || Array(16).fill(null);
      } else {
        boardData = challenges.sort(() => 0.5 - Math.random()).slice(0, 16);
        marked = Array(16).fill(false);
        evidence = Array(16).fill(null);
        playerData.challengeBoard = boardData;
        playerData.challengeMarked = marked;
        playerData.challengeEvidence = evidence;
        await putPlayerFields({ data: JSON.stringify(playerData) });
      }
      renderBoard();
    }

    function renderBoard() {
      boardElement.innerHTML = "";
      boardData.forEach((text, i) => {
        const div = document.createElement("div");
        const icon = evidence[i]?.type === "photo" ? "üì∑" : evidence[i]?.type === "text" ? "üìù" : "";
        div.className = "cell" + (marked[i] ? " marked" : "");
        div.dataset.prooficon = icon;
        div.textContent = text;
        div.onclick = () => handleCellClick(i);
        boardElement.appendChild(div);
      });
      updateProgress();
    }

    function updateProgress() {
      const done = marked.filter(Boolean).length;
      progressText.textContent = `Du har klarat ${done} av 16 utmaningar`;
    }

    function goBack() {
      if (window.history.length > 1) window.history.back();
      else window.location.href = "play.html?id=" + playerId;
    }

    // ====== Flow: require proof before marking ======
    function handleCellClick(index) {
      if (marked[index]) {
        // allow unmark with confirmation ‚Äî removes evidence
        const ok = confirm("Den h√§r rutan √§r markerad. Vill du avmarkera och ta bort beviset?");
        if (!ok) return;
        marked[index] = false;
        evidence[index] = null;
        persist();
        return;
      }
      // Not marked yet ‚Äî open chooser
      pendingIndex = index;
      const task = boardData[index] || "Utmaning";
      chooserTaskText.textContent = `‚Äú${task}‚Äù ‚Äì v√§lj hur du vill l√§gga till bevis`;
      openChooser();
    }

    function openChooser() {
      chooserBackdrop.style.display = "flex";
      chooserBackdrop.setAttribute("aria-hidden", "false");
    }
    function closeChooser() {
      chooserBackdrop.style.display = "none";
      chooserBackdrop.setAttribute("aria-hidden", "true");
    }
    function openTextModal() {
      textBackdrop.style.display = "flex";
      textBackdrop.setAttribute("aria-hidden", "false");
      proofText.value = "";
      const task = boardData[pendingIndex] || "Utmaning";
      textTaskText.textContent = `Skriv vad du gjort f√∂r ‚Äú${task}‚Äù`;
      proofText.focus();
    }
    function closeTextModal() {
      textBackdrop.style.display = "none";
      textBackdrop.setAttribute("aria-hidden", "true");
    }

    // Button wiring
    chooserCancel.addEventListener("click", () => { pendingIndex = null; closeChooser(); });
    textCancel.addEventListener("click", () => { closeTextModal(); openChooser(); });

    chooseTextBtn.addEventListener("click", () => {
      closeChooser();
      openTextModal();
    });

    choosePhotoBtn.addEventListener("click", () => {
      closeChooser();
      // Trigger SAME input as on player page
      photoInput.value = "";
      photoInput.click();
    });

    saveTextProof.addEventListener("click", async () => {
      const txt = (proofText.value || "").trim();
      if (!txt) {
        alert("Skriv n√•got f√∂rst üôè");
        return;
      }
      const idx = pendingIndex;
      if (idx == null) return;
      evidence[idx] = { type: "text", value: txt, ts: Date.now() };
      marked[idx] = true;
      pendingIndex = null;
      closeTextModal();
      await persist();
      alert("Text sparad och rutan markerades!");
    });

    // ---- Cloudinary upload (same flow as player page) ----
    async function uploadPhotoToCloudinary(file) {
      const formData = new FormData();
      formData.append("file", file);
      formData.append("upload_preset", UPLOAD_PRESET);
      const res = await fetch(`https://api.cloudinary.com/v1_1/${CLOUD_NAME}/image/upload`, {
        method: "POST", body: formData
      });
      const json = await res.json();
      if (!json.secure_url) throw new Error("Cloudinary upload failed");
      return json.secure_url;
    }

    // When the user picks/takes a photo
    photoInput.addEventListener("change", async function () {
      const file = this.files && this.files[0];
      if (!file) return;
      const idx = pendingIndex;
      pendingIndex = null;

      try {
        // 1) Upload to Cloudinary
        const imageUrl = await uploadPhotoToCloudinary(file);

        // 2) Save as tile evidence and mark tile
        evidence[idx] = { type: "photo", value: imageUrl, ts: Date.now(), name: file.name };
        marked[idx] = true;

        // 3) Also add to player's gallery
        const player = await getPlayerRow();
        let gallery = [];
        try { gallery = JSON.parse(player.gallery || "[]"); } catch { gallery = []; }
        gallery.push(imageUrl);

        // 4) Persist both data + gallery in a single PUT
        const playerData = {
          ...(player.data ? JSON.parse(player.data) : {}),
          challengeBoard: boardData,
          challengeMarked: marked,
          challengeEvidence: evidence
        };

        await putPlayerFields({
          data: JSON.stringify(playerData),
          gallery: JSON.stringify(gallery)
        });

        renderBoard();
        updateProgress();
        alert("Bilden har laddats upp och rutan markerades!");

      } catch (err) {
        console.error(err);
        alert("Kunde inte ladda upp bilden. F√∂rs√∂k igen.");
      }
    });

    // Persist helper (when not changing gallery)
    async function persist() {
      const player = await getPlayerRow();
      const playerData = {
        ...(player.data ? JSON.parse(player.data) : {}),
        challengeBoard: boardData,
        challengeMarked: marked,
        challengeEvidence: evidence
      };
      await putPlayerFields({ data: JSON.stringify(playerData) });
      renderBoard();
      updateProgress();
    }

    loadBoard();
  </script>
</body>
</html>
